/*
 * Dana Huget, V00860786
 * CSC 225, Fall 2016
 * Assignment 3, part 2
*/

import java.lang.*;
import java.util.*;
import java.io.*;

public class PQ225 {
	//heapArray fields
	private int[] heapArray;
	//number of integers in the heap
	private int size;
	//size to initialize array
	private int arraySize = 1050;
	//true/false to check min heap properties
	private boolean isHeap;
	//integer number of comparisons
	private int cmp;

	//constructor
	public PQ225(){

		heapArray = new int[arraySize];
		size = 0;
		isHeap = false;
		cmp = 0;
	}

//PART 1
	public int getheapArray(int index){
		return heapArray[index];
	}
	/* 
	 * Generates N random numbers in the range LOW to HIGH and inserts them
	 * into the heapArray (generates uniform integer random numbers)
	 * Param: integers n, low and high
	*/
	public void ranGen(int n, int low, int high){
		//populate heapArray with random values
		long seed = System.currentTimeMillis();
		//starting index of heap
		int k = 0;
		Random numGen = new Random(seed);
		int rn;
		while (k < n){
			//generate a random number
			do{
				rn = numGen.nextInt();
			} while (rn < low || high < rn);
			//add random number to array
			heapArray[k] = rn;
			k++;
			size++;
		}
	}

//PART 2
	/*
	 * Returns an integer of size of the array in O(1)
	*/
	public int size(){
		return size;
	}

//PART 2
	/*
	 * Inserts an integer i into the heap in O(log n) time
	 * Param: interger i to be inserted
	 * maintains min heap structure by sifting down integer
	 * of higher value
	*/
	public void insert(int i){
		if(size == arraySize){ //array is full
			System.out.print("Please adjust sizeArray to accommodate additional insert.");
		} else { 
			//insert into next empty index, ie the end of the array
			int cur = size;
			int parent = (cur-1)/2;
			heapArray[cur] = i;
			//while parent is greater than child, swap parent & child
			while(cur >= 0 && heapArray[parent] > heapArray[cur]){
				swap(parent, cur);
				cur = parent;
				parent = (cur-1)/2;
			}
			size++;
		}
	}

//PART 2
	/*
	 * Deletes the smallest integer at root from the heap in O(log n) time
	 * Returns: the deleted integer at root
	 * maintains heap structure by using heapify method
	*/
	public int deleteMin(){
		int temp;
		if(size == 0){
			System.out.print("Cannot remove from empty heapArray.");
			return -1;
		}else{
			temp = heapArray[0];
			heapArray[0] = heapArray[size-1]; //replace root with last element
			size--;
			//will sift down root if it is not the min
			minHeapify(0);
		}
		return temp;
	}

//PART 2
	/*
	 * Turns the unsorted integer array, heapArray into a min heap in O(n) by building
	 * from the bottom up by successively sifting downward to establish the heap
	 * property. After the root integer is sifted down, the array is a min heap.
	 * calls: minHeapify
	*/
	public void makeHeap(){
		/*because we do not need to sift down leaves (which have no
		children, we only need to do this starting at half the array size*/
		for(int i = (size/2); i >= 0; i--){
			minHeapify(i);
		}
	}


	/*
	 * Recursive helper method that ensures min heap structure
	 * Sifts down the integer at index i if it is greater than its children
	 * Params: int i, index of current integer
	 * Calls: swap
	*/	
	private void minHeapify(int i){
		int leftChild = i*2+1;
		int rightChild = i*2+2;
		int min = i;
		//case when left child is smaller than current i
		if(leftChild < size && heapArray[leftChild] < heapArray[i]){
			cmp ++;
			min = leftChild;
		} 
		//case when right child is smaller than min established above
		if(rightChild < size && heapArray[rightChild] < heapArray[min]){
			cmp ++;
			min = rightChild;
		}
		//swap parent & child if current i (parent) is not the min
		if(min != i){	
			swap(i, min);
			//recursive call to sift down new min further
			minHeapify(min);
		} 
		//if they are in the correct order, stop.
	}

//PART 3
	/*
	 * Sorts the int array, heapArray, using In Place Heap Sort in O(n log n)
	 * (nothing specific to return, return type int just for testing purposes)
	 * Calls makeHeap() on heapArray to ensure array is currently a min heap
	 * as well as deleteMin()
	 *
	 * Comparisons will be kept track of in minHeapify(), which is called 
	 * by deleteMin()
	*/
	public int heapsort(){
		makeHeap();
		//keep track of original size because deleteMin recudes size
		int temp = size;
		for(int i = 0; i < temp; i++){
			//instert the root at end of the array (the current size-1)
			heapArray[size-1] = deleteMin();
		}
		//restore original size of now sorted heapArray
		size = temp;
		return 0;
	}

//PART 4
	/*
	 * Tests and exercises the methods developed for the first three parts of this
	 * assignment extensively. The output generated by this class must convince
	 * the marker that the classes are implemented as specified. 
	 * Output written to text file pq_test.txt
	*/
	public void test(){
		try{
    		PrintWriter writer = new PrintWriter("pq_test.txt" , "UTF-8");
    		writer.println("** The following exercises the methods developed by Dana Huget for **"
    			+ "\n** Part One, Two and Three of Assignment 3 (CSC 225, Nov 9, 2016) **");
   			writer.println("\nPopulating heapArray of size 10 with random numbers between 1 and 100");
			writer.println("heapArray: ");
 			int n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
			writer.println("Size of heapArray: " + size());
			writer.println("\nTesting makeHeap method...");
			makeHeap();
			writer.println("heapArray: ");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
 			isHeap();
			if (isHeap == true){
				writer.println("makeHeap !! successfully !! converted ranGen heapArray into a min heap");
			} else {
				writer.println("Error Occurred During makeHeap :(");
			}
			int deleted = deleteMin();
			writer.println("\nRemoving integer at root using deleteMin method: " + deleted);
			writer.println("heapArray: ");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
			writer.println("Size of heapArray: " + size());
			writer.println("\nInserting integers 33, 8, 2, 1, 11, 18, 24 & 20 into heapArray...");
			insert(33);
			insert(8);
			insert(2);
			insert(1);
			insert(11);
			insert(18);
			insert(24);
			insert(20);
			writer.println("heapArray: ");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
			writer.println("Size of heapArray: " + size());
			isHeap();
			if (isHeap == true){
				writer.println("min heap structure maintained after insertion");
			} else {
				writer.println("Error Occurred During Insert :(");
			}
			deleted = deleteMin();
			writer.println("\nRemoving integer at root using deleteMin method: " + deleted);
			writer.println("heapArray: ");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
			writer.println("Size of heapArray: " + size());
			writer.println("\nSorting heapArray using heapsort method...");
			int start = heapsort();
			writer.println("heapArray: ");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
 			reverseHeap();
 			writer.println("\nheapArray converted to ascending order:");
 			n = 0;
 			for (int i = 0 ;i < size; i++) {
 				writer.print(heapArray[i] + " ");
 				n++;
 				if(n == 20){
 					writer.println();
 					n=0;
 				}
 			}
 			writer.println();
 			writer.println("Implementing Heapsort Check");
 			int error = 0;
 			for(int i = 1; i<size;i++){
				if(heapArray[i-1]>heapArray[i]){
					writer.println("\n ** Integers Out of Order: "+ heapArray[i-1] +" "+ heapArray[i] 
						+ " ** :(");
					error = 1;
				} 
			}
			if(error != 1){
				writer.println("\n!! No integers out of ascending order, heapsort passed testing !!");
			}
			/*
		 	 * comparison information for different size arrays with different random numbers
			*/
			//size of heapArray
			int num = 10;
			int high = 100;
			int testNum = 0;
			for(int i = 0; i < 3; i++){
				//integer to keep track of comparison average for multiple tests
    			int average = 0;
    			writer.println("\n-----");
				for(int j = 0; j < 5; j++){
					testNum++;
					writer.println("\n     TEST NUMBER "+testNum);
					//creates new test heapArray
					PQ225 testHeap_re = new PQ225();
					testHeap_re.ranGen(num, 1, high);
					writer.println("\nPopulating heapArray of size "+num+ " with random numbers "
						+ "between 1 and " + high);
					writer.println("Calling heapsort on ranGen heapArray and implementing"
						+ " Heapsort Check\n");
					long startTime = System.currentTimeMillis();
					testHeap_re.heapsort();
					testHeap_re.reverseHeap();
					error = 0;
		 			for(int k = 1; k<testHeap_re.size();k++){
						if(testHeap_re.heapArray[k-1]>testHeap_re.heapArray[k]){
							writer.println("** Integers Out of Order: "+ testHeap_re.heapArray[i-1] 
								+" "+ testHeap_re.heapArray[i] + " ** :(");
							error = 1;
						} 
					}
					if(error != 1){
						writer.println("!! No integers out of ascending order, heapsort passed testing !!");
					}
					long endTime = System.currentTimeMillis();
					double totalTimeSeconds = (endTime - startTime) / 1000.0;
					writer.println("Total Sorting Time (seconds): " + totalTimeSeconds);
					writer.println("Total Comparisons = " + testHeap_re.getComparisons());
					average += testHeap_re.getComparisons();
				}
				writer.println("\n>>> Average of Comparisons for Five Tests on Arrays of Size "+num
					+" = "+ average/5);
				num = num*10;
				high = high*5;
			}
			writer.println("\n-----\n");
			writer.println("testing has concluded, have a nice day :)");
			writer.close();
		} catch (Exception e) {
   			System.out.println("Unable to write to test file pq_test.txt");
		}	
	}

	/*
	 * Helper method that swaps the position of two integers
	 * params: two ints that represent the index of the items to be swapped
	 * Called by minHeapify()
	*/	
	private void swap(int a, int b) {
		//store value at a in temp
		int temp = heapArray[a];
		//replace value at a with value at b
		heapArray[a] = heapArray[b];
		//replace value at b with temp
		heapArray[b] = temp;
	}

	/*
	 * Returns the number of comparisons generated by heapsort
	*/
	public int getComparisons(){
		return cmp;
	}
	/*
	 * String representation of the heapArray
	*/
 	public void printHeap() {
 		System.out.print("heapArray: " + heapArray[0]);
 		for (int i = 1 ;i < size; i++) {
 			System.out.print(", " + heapArray[i]);
 		}
 		System.out.println();	
 	}
 
 	/*
	 * A method for determining if heapArray is a min heap satisfying
	 * the following: parent is less than its children 
	*/
	public boolean isHeap(){
		int parent = 0;
		int leftChild = parent*2+1;
		int rightChild = parent*2+2;
		isHeap = false;
			while(parent < size && heapArray[parent] < heapArray[leftChild] 
									&& heapArray[parent] < heapArray[rightChild]){
				isHeap = true;
				parent++;
				leftChild = parent*2+1;
				rightChild = parent*2+2;
			}
		return isHeap;
	}	

	/*
	 * A method to reverse the descending order of the sorted heapArray
	 * sorted heapArray will be then be in ascending order for easier 
	 * analysis when performing Heapsort Check
	*/
	private void reverseHeap(){
		int end = size-1;
		for (int i = 0; i < size/2 ; i++) {
			swap(i, end);
			end--;
		}
	}

	public static boolean ensureMin(int elem, int[] elems) {
        boolean b = true;
        for (int i = 0; i < elems.length; i++) {
            if (elem < elems[i]) {
                b = false;
                break;
            }
        }
        return b;
    }
	/*
	 * main method purpose is to create a new PQ225 object and call test method
	*/
	public static void main(String[] args){
		/*PQ225 testHeap = new PQ225();
		testHeap.ranGen(10, 1, 30);
		testHeap.test();
		System.out.println("Test Report written to pq_test.txt");
		*/
		PQ225 heap = new PQ225();
		heap.ranGen(5, 0, 2000);
		heap.makeHeap();
		heap.printHeap();
		heap.heapsort();
		heap.reverseHeap();
		heap.printHeap();
		boolean deleteOk = false, sorted = false;
        int[] elements = new int[5], copy = new int[5];
        for (int i = 0; i < 5; i++) {
        	//getheapArray(int index)
            elements[i] = heap.deleteMin();
            copy[i] = elements[i];
            System.out.println("deletedMin " + elements[i]);
            //deleteOk &= ensureMin(elements[i], elements);
            deleteOk = ensureMin(elements[i], elements);
        }
        java.util.Arrays.sort(copy);
        sorted = Arrays.equals(elements, copy);

        // ...

        System.out.println("deleteMin is: " + deleteOk);
        //verify sorted is true
        System.out.println("sorted is: " + sorted);

        boolean insertOk = true;
        int[] known = {90, 80, 70, 60, 50, 40};
        for (int i = 0; i < known.length; i++) {
            heap.insert(known[i]);
        }
        known = new int[]{40, 50, 60, 70, 80, 90};
        for (int i = 0; i < known.length; i++) {
        	int min = heap.deleteMin();
            if (min != known[i]) {
                System.out.println("NOT THE SAME: " + min + " and " + known[i]);
                insertOk = false;
                break;
            }
        }
        //verify insertOK is true
        System.out.println("instert is: " + insertOk);
	}
}